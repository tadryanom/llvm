//===-- TileISelDAGToDAG.cpp - A Dag to Dag Inst Selector for Tile --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the Tile target.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "tile-isel"
#include "Tile.h"
#include "TileMachineFunction.h"
#include "TileRegisterInfo.h"
#include "TileSubtarget.h"
#include "TileTargetMachine.h"
#include "MCTargetDesc/TileBaseInfo.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/CFG.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

namespace {

class TileDAGToDAGISel : public SelectionDAGISel {

  // Keep a reference to TileTargetMachine.
  TileTargetMachine &TM;

  // Keep a pointer to the TileSubtarget around so that we can make
  // the right decision when generating code for different targets.
  const TileSubtarget &Subtarget;

public:
  explicit TileDAGToDAGISel(TileTargetMachine &tm)
      : SelectionDAGISel(tm), TM(tm),
        Subtarget(tm.getSubtarget<TileSubtarget>()) {}

  // Pass Name.
  virtual const char *getPassName() const {
    return "Tile DAG->DAG Pattern Instruction Selection";
  }

  virtual bool runOnMachineFunction(MachineFunction &MF);

private:
// Include the pieces autogenerated from the target description.
#include "TileGenDAGISel.inc"

  // Return a reference to the TargetMachine,
  // casted to the target-specific type.
  const TileTargetMachine &getTargetMachine() {
    return static_cast<const TileTargetMachine &>(TM);
  }

  // Return a reference to the TargetInstrInfo,
  // casted to the target-specific type.
  const TileInstrInfo *getInstrInfo() {
    return getTargetMachine().getInstrInfo();
  }

  // Output the instructions required to put the GOT address into a register.
  SDNode *getGlobalBaseReg();

  // Output the instructions required to put the current pc into a register.
  SDNode *getLinkReg();

  // Select instructions not customized.
  SDNode *Select(SDNode *N);

  // Complex Pattern.
  bool SelectFI(SDValue N, SDValue &R1);

  // Return a target constant with the specified value.
  inline SDValue getImm(const SDNode *Node, unsigned Imm) {
    return CurDAG->getTargetConstant(Imm, Node->getValueType(0));
  }

  void ProcessFunctionAfterISel(MachineFunction &MF);
  bool ReplaceUsesWithZeroReg(MachineRegisterInfo *MRI, const MachineInstr &);
  void GenPICHeader(MachineFunction &MF);

  virtual bool SelectInlineAsmMemoryOperand(
      const SDValue &Op, char ConstraintCode, std::vector<SDValue> &OutOps);
};

}

// Insert PIC header to initialize gp.
void TileDAGToDAGISel::GenPICHeader(MachineFunction &MF) {
  TileFunctionInfo *TileFI = MF.getInfo<TileFunctionInfo>();

  if (!TileFI->globalBaseRegSet() && !TileFI->linkRegSet())
    return;

  MachineBasicBlock &MBB = MF.front();
  MachineBasicBlock::iterator I = MBB.begin();
  const TargetInstrInfo &TII = *MF.getTarget().getInstrInfo();
  DebugLoc DL = I != MBB.end() ? I->getDebugLoc() : DebugLoc();
  unsigned GP = TileFI->getGlobalBaseReg();
  unsigned LP = TileFI->getLinkReg();

  BuildMI(MBB, I, DL, TII.get(Tile::LNK), LP)
      .addExternalSymbol("HOLDER", TileII::MO_NO_FLAG_PIC);

  if (!TileFI->globalBaseRegSet())
    return;

  BuildMI(MBB, I, DL, TII.get(Tile::MOVELI), GP)
      .addExternalSymbol("_GLOBAL_OFFSET_TABLE_", TileII::MO_HW1_LAST_PIC);
  BuildMI(MBB, I, DL, TII.get(Tile::SHL16INSLI), GP).addReg(GP)
      .addExternalSymbol("_GLOBAL_OFFSET_TABLE_", TileII::MO_HW0_PIC);
  BuildMI(MBB, I, DL, TII.get(Tile::ADD), GP).addReg(GP).addReg(LP);
  return;
}

bool TileDAGToDAGISel::ReplaceUsesWithZeroReg(MachineRegisterInfo *MRI,
                                              const MachineInstr &MI) {
  unsigned DstReg = 0, ZeroReg = 0;

  // Check if MI is "addi/addli/addxi/addxli $dst, $zero, 0".
  if ((MI.getOpcode() == Tile::ADDI || MI.getOpcode() == Tile::ADDLI) &&
      (MI.getOperand(1).getReg() == Tile::ZERO) &&
      (MI.getOperand(2).getImm() == 0)) {
    DstReg = MI.getOperand(0).getReg();
    ZeroReg = Tile::ZERO;
  } else if ((MI.getOpcode() == Tile::ADDXI ||
              MI.getOpcode() == Tile::ADDXLI) &&
             (MI.getOperand(1).getReg() == Tile::ZERO_32) &&
             (MI.getOperand(2).getImm() == 0)) {
    DstReg = MI.getOperand(0).getReg();
    ZeroReg = Tile::ZERO_32;
  }

  if (!DstReg)
    return false;

  // Replace uses with ZeroReg.
  for (MachineRegisterInfo::use_iterator U = MRI->use_begin(DstReg),
                                         E = MRI->use_end();
       U != E; ++U) {
    MachineOperand &MO = U.getOperand();
    MachineInstr *MI = MO.getParent();

    // Do not replace if it is a phi's operand or is tied to def operand.
    if (MI->isPHI() || MI->isRegTiedToDefOperand(U.getOperandNo()))
      continue;

    MO.setReg(ZeroReg);
  }

  return true;
}

void TileDAGToDAGISel::ProcessFunctionAfterISel(MachineFunction &MF) {
  GenPICHeader(MF);

  MachineRegisterInfo *MRI = &MF.getRegInfo();

  for (MachineFunction::iterator MFI = MF.begin(), MFE = MF.end(); MFI != MFE;
       ++MFI)
    for (MachineBasicBlock::iterator I = MFI->begin(); I != MFI->end(); ++I)
      ReplaceUsesWithZeroReg(MRI, *I);
}

bool TileDAGToDAGISel::runOnMachineFunction(MachineFunction &MF) {
  bool Ret = SelectionDAGISel::runOnMachineFunction(MF);

  ProcessFunctionAfterISel(MF);

  return Ret;
}

SDNode *TileDAGToDAGISel::getGlobalBaseReg() {
  unsigned GlobalBaseReg = MF->getInfo<TileFunctionInfo>()->getGlobalBaseReg();
  return CurDAG->getRegister(GlobalBaseReg, TLI.getPointerTy()).getNode();
}

SDNode *TileDAGToDAGISel::getLinkReg() {
  unsigned LinkReg = MF->getInfo<TileFunctionInfo>()->getLinkReg();
  return CurDAG->getRegister(LinkReg, TLI.getPointerTy()).getNode();
}

bool TileDAGToDAGISel::SelectFI(SDValue N, SDValue &R1) {
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N)) {
    R1 = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
    return true;
  }
  return false;
}

SDNode *TileDAGToDAGISel::Select(SDNode *Node) {
  unsigned Opcode = Node->getOpcode();
  DebugLoc dl = Node->getDebugLoc();

  // Dump information about the Node being selected.
  DEBUG(errs() << "Selecting: "; Node->dump(CurDAG); errs() << "\n");

  // If we have a custom node, we already have selected.
  if (Node->isMachineOpcode()) {
    DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    return NULL;
  }

  // Instruction Selection not handled by the auto-generated
  // tablegen selection should be handled here.
  EVT NodeTy = Node->getValueType(0);

  switch (Opcode) {
  default:
    break;

  // Carry-bit add/sub.
  case ISD::SUBE:
  case ISD::ADDE: {
    SDValue InFlag = Node->getOperand(2), CmpLHS;
    unsigned Opc = InFlag.getOpcode();
    (void) Opc;
    assert(((Opc == ISD::ADDC || Opc == ISD::ADDE) ||
            (Opc == ISD::SUBC || Opc == ISD::SUBE)) &&
           "(ADD|SUB)E flag operand must come from (ADD|SUB)C/E insn");

    unsigned MOp;
    if (Opcode == ISD::ADDE) {
      CmpLHS = InFlag.getValue(0);
      MOp = NodeTy == MVT::i64 ? Tile::ADD : Tile::ADDX;
    } else {
      CmpLHS = InFlag.getOperand(0);
      MOp = NodeTy == MVT::i64 ? Tile::SUB : Tile::SUBX;
    }

    SDValue Ops[] = { CmpLHS, InFlag.getOperand(1) };

    SDValue LHS = Node->getOperand(0);
    SDValue RHS = Node->getOperand(1);

    EVT VT = LHS.getValueType();
    SDNode *Carry = CurDAG->getMachineNode(
        NodeTy == MVT::i64 ? Tile::CMPLTU : Tile::CMPLTU32, dl, VT, Ops, 2);
    SDNode *AddCarry =
        CurDAG->getMachineNode(NodeTy == MVT::i64 ? Tile::ADD : Tile::ADDX, dl,
                               VT, SDValue(Carry, 0), RHS);

    return CurDAG->SelectNodeTo(Node, MOp, VT, MVT::Glue, LHS,
                                SDValue(AddCarry, 0));
  }

  // 64bit mul.
  case ISD::MUL: {

    if (NodeTy == MVT::i32)
      break;

    SDNode *Temp =
        CurDAG->getMachineNode(Tile::MUL_HU_LU, dl, MVT::i64,
                               Node->getOperand(0), Node->getOperand(1));

    Temp =
        CurDAG->getMachineNode(Tile::MULA_HU_LU, dl, MVT::i64, SDValue(Temp, 0),
                               Node->getOperand(1), Node->getOperand(0));

    Temp = CurDAG->getMachineNode(Tile::SHLI, dl, MVT::i64, SDValue(Temp, 0),
                                  CurDAG->getTargetConstant(32, MVT::i64));

    return CurDAG->getMachineNode(Tile::MULA_LU_LU, dl, MVT::i64,
                                  SDValue(Temp, 0), Node->getOperand(1),
                                  Node->getOperand(0));
  }

  case ISD::FMUL: {

    if (NodeTy == MVT::f32)
      break;

    // for f64 multiply, TILE-Gx need to use
    // instruction sequences to finish the work.
    //
    // this sequences is copied from TILE-Gx gcc.
    SDNode *Temp0 =
        CurDAG->getMachineNode(Tile::FDOUBLE_UNPACK_MAX, dl, MVT::f64,
                               Node->getOperand(0), CurDAG->getRegister(Tile::ZERO, MVT::f64));
    SDNode *Temp1 =
        CurDAG->getMachineNode(Tile::FDOUBLE_UNPACK_MAX, dl, MVT::f64,
                               Node->getOperand(1), CurDAG->getRegister(Tile::ZERO, MVT::f64));
    SDNode *Temp2 =
        CurDAG->getMachineNode(Tile::FDOUBLE_MUL_FLAGS, dl, MVT::f64,
                               Node->getOperand(0), Node->getOperand(1));
    SDNode *Temp3 =
        CurDAG->getMachineNode(Tile::MUL_LU_LU, dl, MVT::f64,
                               SDValue(Temp0, 0), SDValue(Temp1, 0));
    SDNode *Temp4 =
        CurDAG->getMachineNode(Tile::MUL_HU_LU, dl, MVT::f64,
                               SDValue(Temp0, 0), SDValue(Temp1, 0));
    SDNode *Temp5 =
        CurDAG->getMachineNode(Tile::MULA_HU_LU, dl, MVT::f64, SDValue(Temp4, 0),
                               SDValue(Temp1, 0), SDValue(Temp0, 0));
    SDNode *Temp6 =
        CurDAG->getMachineNode(Tile::MUL_HU_HU, dl, MVT::f64,
                               SDValue(Temp0, 0), SDValue(Temp1, 0));
    SDNode *Temp7 =
        CurDAG->getMachineNode(Tile::SHLI, dl, MVT::i64,
                               SDValue(Temp5, 0), CurDAG->getTargetConstant(32, MVT::i64));
    SDNode *Temp8 =
        CurDAG->getMachineNode(Tile::SHRUI, dl, MVT::i64,
                               SDValue(Temp5, 0), CurDAG->getTargetConstant(32, MVT::i64));
    SDNode *Temp9 =
        CurDAG->getMachineNode(Tile::ADD, dl, MVT::i64,
                               SDValue(Temp6, 0), SDValue(Temp8, 0));
    SDNode *Temp10 =
        CurDAG->getMachineNode(Tile::ADD, dl, MVT::i64,
                               SDValue(Temp3, 0), SDValue(Temp7, 0));

    SDNode *Temp11 =
        CurDAG->getMachineNode(Tile::CMPLTU, dl, MVT::i64,
                               SDValue(Temp10, 0), SDValue(Temp7, 0));

    SDNode *Temp12 =
        CurDAG->getMachineNode(Tile::ADD, dl, MVT::i64,
                               SDValue(Temp9, 0), SDValue(Temp11, 0));

    SDNode *Temp13 =
        CurDAG->getMachineNode(Tile::FDOUBLE_PACK1, dl, MVT::f64,
                               SDValue(Temp12, 0), SDValue(Temp2, 0));

   return CurDAG->getMachineNode(Tile::FDOUBLE_PACK2, dl, MVT::f64,
                               SDValue(Temp12, 0), SDValue(Temp10, 0), SDValue(Temp13, 0));
  }

  // Get target GOT address.
  case ISD::GLOBAL_OFFSET_TABLE:
    return getGlobalBaseReg();
  }

  // Select the default instruction.
  SDNode *ResNode = SelectCode(Node);

  DEBUG(errs() << "=> ");
  if (ResNode == NULL || ResNode == Node)
    DEBUG(Node->dump(CurDAG));
  else
    DEBUG(ResNode->dump(CurDAG));
  DEBUG(errs() << "\n");
  return ResNode;
}

bool TileDAGToDAGISel::SelectInlineAsmMemoryOperand(
    const SDValue &Op, char ConstraintCode, std::vector<SDValue> &OutOps) {
  assert(ConstraintCode == 'm' && "unexpected asm memory constraint");
  OutOps.push_back(Op);
  return false;
}

// This pass converts a legalized DAG into a Tile-specific DAG,
// ready for instruction scheduling.
FunctionPass *llvm::createTileISelDag(TileTargetMachine &TM) {
  return new TileDAGToDAGISel(TM);
}
